/*
 * Bosch IoT Suite - Device Provisioning
 *
 * The Device Provisioning API is used to provision new devices for the Bosch IoT Suite services. It simplifies provisioning by registering the device in all affected services with a single API call.  Currently the Bosch IoT Hub and Bosch IoT Things service are supported. The following entities can be provisioned: * **Device** (Bosch IoT Hub): The Bosch IoT Hub has to be made aware of the Device which will connect to it and send telemetry data. * **Credentials** (Bosch IoT Hub): Credentials are required to authenticate Devices which want to connect. If Devices connect via a gateway, only credentials for the gateway are required. Hence, Credentials are optional in the Device Provisioning API. * **Thing** (Bosch IoT Things): A Thing is a *Digital Twin*: Among other things, it stores the state of the Device and provides an API for it, which is also called *Device-as-a-Service*. [Vorto models](https://vorto.eclipse.org) can be used to define the capabilities of a Thing. * **Policy** (Bosch IoT Things): Each Thing must have a reference (`policyId`) to a Policy which defines its access  control. You can decide to create a specific Policy for each Thing or to re-use a Policy for multiple Things.  Authentication and authorization of the Device Provisioning API is based on *Suite Auth* access tokens. You have to create a Suite Auth access token which provides full access to the Bosch IoT Hub and Bosch IoT Things service instances you want to address and provide it as *Bearer Authorization*.  **Note**: If you are using the Asset communication package hybrid offering please use the following server: - https://deviceprovisioning.eu-h1.bosch-iot-suite.com/api/1 
 *
 * API version: 1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package iotdevprov

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// ProvisioningApiService ProvisioningApi service
type ProvisioningApiService service

// ServiceInstanceIdDevicesPostOpts Optional parameters for the method 'ServiceInstanceIdDevicesPost'
type ServiceInstanceIdDevicesPostOpts struct {
    AuthScope optional.String
    SkipVorto optional.Bool
    ProvisioningRequestPayload optional.Interface
}

/*
ServiceInstanceIdDevicesPost Provision a device: Creates the required resources in the underlying Bosch IoT Suite services. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceInstanceId The ID of the Bosch IoT Suite for Asset Communication subscription for which you want to provision a device. Not the IDs of the underlying Bosch IoT Hub or Bosch IoT Things service instance. 
 * @param optional nil or *ServiceInstanceIdDevicesPostOpts - Optional Parameters:
 * @param "AuthScope" (optional.String) -  Controls who owns the newly created Thing (i.e. which subject is used for the default entry of the created Policy). If this parameter is omitted the authenticated subject of the user who made the request is used (Things default).  Supported scopes: * `subscription`: full access is granted to all users who have access to the same IoT Suite subscription 
 * @param "SkipVorto" (optional.Bool) -  If set to true, the resolution of the Vorto model from the definition field of the Thing will not be attempted. 
 * @param "ProvisioningRequestPayload" (optional.Interface of ProvisioningRequestPayload) - 
@return ProvisioningResponsePayload
*/
func (a *ProvisioningApiService) ServiceInstanceIdDevicesPost(ctx _context.Context, serviceInstanceId string, localVarOptionals *ServiceInstanceIdDevicesPostOpts) (ProvisioningResponsePayload, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProvisioningResponsePayload
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{service-instance-id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"service-instance-id"+"}", _neturl.QueryEscape(parameterToString(serviceInstanceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AuthScope.IsSet() {
		localVarQueryParams.Add("authScope", parameterToString(localVarOptionals.AuthScope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SkipVorto.IsSet() {
		localVarQueryParams.Add("skipVorto", parameterToString(localVarOptionals.SkipVorto.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.ProvisioningRequestPayload.IsSet() {
		localVarOptionalProvisioningRequestPayload, localVarOptionalProvisioningRequestPayloadok := localVarOptionals.ProvisioningRequestPayload.Value().(ProvisioningRequestPayload)
		if !localVarOptionalProvisioningRequestPayloadok {
			return localVarReturnValue, nil, reportError("provisioningRequestPayload should be ProvisioningRequestPayload")
		}
		localVarPostBody = &localVarOptionalProvisioningRequestPayload
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Provisioning400ErrorPayload
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
