/*
 * Bosch IoT Suite - Device Provisioning
 *
 * The Device Provisioning API is used to provision new devices for the Bosch IoT Suite services. It simplifies provisioning by registering the device in all affected services with a single API call.  Currently the Bosch IoT Hub and Bosch IoT Things service are supported. The following entities can be provisioned: * **Device** (Bosch IoT Hub): The Bosch IoT Hub has to be made aware of the Device which will connect to it and send telemetry data. * **Credentials** (Bosch IoT Hub): Credentials are required to authenticate Devices which want to connect. If Devices connect via a gateway, only credentials for the gateway are required. Hence, Credentials are optional in the Device Provisioning API. * **Thing** (Bosch IoT Things): A Thing is a *Digital Twin*: Among other things, it stores the state of the Device and provides an API for it, which is also called *Device-as-a-Service*. [Vorto models](https://vorto.eclipse.org) can be used to define the capabilities of a Thing. * **Policy** (Bosch IoT Things): Each Thing must have a reference (`policyId`) to a Policy which defines its access  control. You can decide to create a specific Policy for each Thing or to re-use a Policy for multiple Things.  Authentication and authorization of the Device Provisioning API is based on *Suite Auth* access tokens. You have to create a Suite Auth access token which provides full access to the Bosch IoT Hub and Bosch IoT Things service instances you want to address and provide it as *Bearer Authorization*.  **Note**: If you are using the Asset communication package hybrid offering please use the following server: - https://deviceprovisioning.eu-h1.bosch-iot-suite.com/api/1 
 *
 * API version: 1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package iotdevprov

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// DeProvisioningApiService DeProvisioningApi service
type DeProvisioningApiService service

// ServiceInstanceIdDevicesDeviceIdDeleteOpts Optional parameters for the method 'ServiceInstanceIdDevicesDeviceIdDelete'
type ServiceInstanceIdDevicesDeviceIdDeleteOpts struct {
    KeepCredentials optional.Bool
    KeepPolicy optional.Bool
}

/*
ServiceInstanceIdDevicesDeviceIdDelete De-provisioning a device: Deletes the device, thing, policy and credentials by ID in the underlying Bosch IoT Suite services. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceInstanceId The ID of the Bosch IoT Suite for Asset Communication subscription for which you want to de-provision a device. Not the IDs of the underlying Bosch IoT Hub or Bosch IoT Things service instance. 
 * @param deviceId The ID of the device you want to de-provision
 * @param optional nil or *ServiceInstanceIdDevicesDeviceIdDeleteOpts - Optional Parameters:
 * @param "KeepCredentials" (optional.Bool) -  Pass 'true' if you wish to keep the device's credentials
 * @param "KeepPolicy" (optional.Bool) -  Pass 'true' if you wish to keep the thing's policy
@return DeprovisioningResponsePayload
*/
func (a *DeProvisioningApiService) ServiceInstanceIdDevicesDeviceIdDelete(ctx _context.Context, serviceInstanceId string, deviceId string, localVarOptionals *ServiceInstanceIdDevicesDeviceIdDeleteOpts) (DeprovisioningResponsePayload, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeprovisioningResponsePayload
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{service-instance-id}/devices/{device-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"service-instance-id"+"}", _neturl.QueryEscape(parameterToString(serviceInstanceId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.QueryEscape(parameterToString(deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.KeepCredentials.IsSet() {
		localVarQueryParams.Add("keepCredentials", parameterToString(localVarOptionals.KeepCredentials.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KeepPolicy.IsSet() {
		localVarQueryParams.Add("keepPolicy", parameterToString(localVarOptionals.KeepPolicy.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
